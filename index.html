<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Salto Livre: A Ascensão do Conhecimento</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0c0a18; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Press Start 2P', cursive;
            color: white;
        }
        #gameContainer {
            position: relative;
            box-shadow: 0 0 25px #00BFFF, inset 0 0 15px #008FFF;
            border-radius: 10px; 
            overflow: hidden;
            background-color: #120c1c; 
        }
        #gameCanvas {
            display: block;
            background: linear-gradient(to bottom, #1f0c3d, #0a0313); 
        }
        .touch-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            cursor: pointer;
        }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #FFF;
            font-size: 1em; 
            font-weight: 700;
            text-shadow: 0 0 5px #00BFFF, 0 0 10px #00BFFF; 
            z-index: 20;
            padding: 5px 10px;
            background-color: rgba(12, 10, 24, 0.4); 
            border-radius: 8px; 
        }
        #softwareIcon {
            font-size: 1.2em;
            vertical-align: middle;
            margin-right: 5px;
        }
        #messageOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(12, 10, 24, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 30;
            padding: 20px;
            box-sizing: border-box;
        }
        #messageOverlay h2 {
            font-size: 1.8em;
            color: #FF4136; 
            margin-bottom: 15px;
            text-shadow: 0 0 8px #FF4136;
        }
        #messageOverlay p {
            font-size: 0.9em;
            margin-bottom: 20px;
            line-height: 1.5;
        }
        #messageOverlay button {
            background-color: #00BFFF;
            color: white;
            border: 2px solid #FFFFFF;
            border-radius: 8px; 
            padding: 12px 25px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 10px #00BFFF;
            transition: background-color 0.2s, transform 0.1s;
        }
        #messageOverlay button:hover {
            background-color: #009ACD;
        }
        #messageOverlay button:active {
            transform: scale(0.95); 
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="hud">
            <div id="scoreDisplay">Progresso: 0Kb</div>
            <div id="softwareDisplay"><span id="softwareIcon">💾</span> <span id="softwareCount">0</span></div>
        </div>
        <div class="touch-overlay" id="touchControl"></div>
        <div id="messageOverlay" style="display: none;">
            <h2 id="messageTitle">Bug Encontrado!</h2>
            <p id="finalScoreMessage">Seu progresso: 0Kb</p>
            <p id="finalSoftwareMessage">Softwares coletados: 0</p>
            <button id="restartButton">Tentar Novamente</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');
        
        const scoreDisplay = document.getElementById('scoreDisplay');
        const softwareCountDisplay = document.getElementById('softwareCount'); 
        const touchControl = document.getElementById('touchControl');
        const messageOverlay = document.getElementById('messageOverlay');
        const messageTitle = document.getElementById('messageTitle');
        const finalScoreMessage = document.getElementById('finalScoreMessage');
        const finalSoftwareMessage = document.getElementById('finalSoftwareMessage');
        const restartButton = document.getElementById('restartButton');

        ctx.imageSmoothingEnabled = false;

        let aspectRatio = 9 / 16;
        let gameWidth, gameHeight;

        let player, platforms, softwareItems, obstacles, cameraY, score, collectedSoftware, gameState, particles;
        let initialPlayerWorldY, lastDividerY, DIVIDER_INTERVAL_Y;
        let lastPlatformHadObstacle = false;
        let lastGeneratedPlatformType = null;
        let stars = [];

        const PLAYER_DEFAULTS = {
            widthRatio: 0.08, 
            speedRatio: 0.0095,
            jumpStrengthRatio: 0.018,
            doubleJumpStrengthRatio: 0.017,
            gravityRatio: 0.00048,          
            boostJumpStrengthRatio: 0.032,
        };

        const SOFTWARE_SYMBOLS = ['📄', '🎨', '🐧', '>_', '🦊', '🎧', '🖌️'];
        const OBSTACLE_SYMBOLS = ['💲', '🐛', '🔒', '💀', '⛓️'];

        let soundInitialized = false;
        let jumpSound, doubleJumpSound, collectSound, hurtSound, breakSound, boostSound;

        async function initSounds() {
            if (soundInitialized || typeof Tone === 'undefined') return;
            try {
                await Tone.start();
                jumpSound = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 }, volume: -7 }).toDestination();
                doubleJumpSound = new Tone.Synth({ oscillator: { type: "triangle", frequency: "D5" }, envelope: { attack: 0.005, decay: 0.08, sustain: 0.02, release: 0.1 }, volume: -9 }).toDestination();
                collectSound = new Tone.Synth({ oscillator: { type: "square", frequency:"C6" }, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }, volume: -10 }).toDestination();
                hurtSound = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.1 }, volume: -6 }).toDestination();
                breakSound = new Tone.MembraneSynth({ pitchDecay: 0.08, octaves: 2.5, envelope: { attack: 0.001, decay: 0.25, sustain: 0.01, release: 0.25}, volume: -9 }).toDestination();
                boostSound = new Tone.Synth({ oscillator: { type: "pulse", width:0.4 }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.2 }, volume: -7 }).toDestination();
                soundInitialized = true;
            } catch (e) { console.error("Falha ao iniciar Tone.js:", e); }
        }
        
        function resizeGame() {
            const availableHeight = window.innerHeight;
            const availableWidth = window.innerWidth;

            if (availableHeight * aspectRatio > availableWidth) {
                gameWidth = availableWidth; 
                gameHeight = gameWidth / aspectRatio;
            } else {
                gameHeight = availableHeight;
                gameWidth = gameHeight * aspectRatio;
            }

            canvas.width = gameWidth;
            canvas.height = gameHeight;
            gameContainer.style.width = `${gameWidth}px`;
            gameContainer.style.height = `${gameHeight}px`;
            
            DIVIDER_INTERVAL_Y = gameHeight * 1.0;

            generateStars();
        }

        function generateStars() { 
            stars = [];
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * gameWidth,
                    y: Math.random() * gameHeight,
                    size: Math.random() * 1.5 + 0.5, 
                    opacity: Math.random() * 0.7 + 0.3, 
                    speedFactor: Math.random() * 0.3 + 0.1
                });
            }
        }
        
        function drawStars() { 
            ctx.save();
            stars.forEach(star => {
                const parallaxY = star.y + cameraY * star.speedFactor;
                const screenY = ((parallaxY % gameHeight) + gameHeight) % gameHeight;
                ctx.fillStyle = `rgba(200, 220, 255, ${star.opacity})`; 
                ctx.beginPath();
                ctx.arc(star.x, screenY, star.size, 0, Math.PI * 2); 
                ctx.fill();
            });
            ctx.restore();
        }

        function initGame() {
            resizeGame(); 
            
            player = {
                width: gameWidth * PLAYER_DEFAULTS.widthRatio,
                height: (gameWidth * PLAYER_DEFAULTS.widthRatio) * 1.25,
                speed: gameWidth * PLAYER_DEFAULTS.speedRatio,
                jumpStrength: gameHeight * PLAYER_DEFAULTS.jumpStrengthRatio,
                doubleJumpStrength: gameHeight * PLAYER_DEFAULTS.doubleJumpStrengthRatio,
                gravity: gameHeight * PLAYER_DEFAULTS.gravityRatio,
                boostJumpStrength: gameHeight * PLAYER_DEFAULTS.boostJumpStrengthRatio,
                vx: 0,
                vy: 0,
                canDoubleJump: false,
            };
            player.x = gameWidth / 2 - player.width / 2;
            player.y = gameHeight - player.height - (gameHeight * 0.05); 
            
            initialPlayerWorldY = player.y;
            platforms = []; 
            softwareItems = []; 
            obstacles = [];
            particles = [];
            
            generateInitialPlatforms();
            lastDividerY = platforms[0].y;
            lastPlatformHadObstacle = false; 
            lastGeneratedPlatformType = 'divider'; 

            for(let i = 0; i < 15; i++) { 
                const lastP = platforms[platforms.length - 1]; 
                let nextY = lastP.y - (gameHeight * (0.15 + Math.random() * 0.15)); 
                let shouldForceDivider = (lastDividerY - nextY) >= DIVIDER_INTERVAL_Y;
                generateNewElements(nextY, false, shouldForceDivider);
            }
            
            cameraY = player.y - gameHeight * 0.65;
            score = 0; 
            collectedSoftware = 0; 
            gameState = 'playing';
            messageOverlay.style.display = 'none';
            updateHUD();
        }

        function generateInitialPlatforms() {
            const basePlatformHeight = gameHeight * 0.05; 
            platforms.push({
                x: 0, y: gameHeight - basePlatformHeight, 
                width: gameWidth, height: basePlatformHeight,
                type: 'divider',
                color: '#263238', borderColor: '#102027', shadowColor: '#4f5b62',
                isBroken: false, breakTimer: 0, hasObstacle: false 
            });
        }
        
        const PLATFORM_COLORS = {
            normal: { main: '#4A6572', border: '#607D8B', shadow: '#00BFFF' }, 
            breakable: { main: '#FF8F00', border: '#FFB300', shadow: '#FFD54F', brokenColor: '#A1887F' }, 
            boost: { main: '#4DD0E1', border: '#26C6DA', shadow: '#80DEEA' },
            divider: { main: '#263238', border: '#102027', shadow: '#4f5b62'}
        };

        function generateNewElements(yPos, isInitial = false, forceDivider = false) {
            if (forceDivider) {
                platforms.push({
                    x: 0, y: yPos, width: gameWidth, height: gameHeight * 0.05,
                    type: 'divider', 
                    color: PLATFORM_COLORS.divider.main, borderColor: PLATFORM_COLORS.divider.border, shadowColor: PLATFORM_COLORS.divider.shadow,
                    isBroken: false, breakTimer: 0, hasObstacle: false
                });
                lastDividerY = yPos; 
                lastPlatformHadObstacle = false; 
                lastGeneratedPlatformType = 'divider';
                return; 
            }

            const platformTypeRoll = Math.random();
            let platformType = (platformTypeRoll < 0.15 && lastGeneratedPlatformType !== 'breakable') ? 'breakable' 
                             : (platformTypeRoll < 0.40) ? 'boost' 
                             : 'normal';

            const platformWidth = (Math.random() * (gameWidth * 0.33)) + (gameWidth * 0.22);
            const platformHeight = gameHeight * 0.038; 
            const platformX = Math.random() * (gameWidth - platformWidth);
            const colorSet = PLATFORM_COLORS[platformType];

            const newPlatform = {
                x: platformX, y: yPos, width: platformWidth, height: platformHeight,
                type: platformType, 
                color: colorSet.main, borderColor: colorSet.border, shadowColor: colorSet.shadow,
                isBroken: false, breakTimer: 0, hasObstacle: false 
            };
            platforms.push(newPlatform);
            lastGeneratedPlatformType = platformType;

            if (platformType === 'normal' && !lastPlatformHadObstacle && Math.random() < 0.20) {
                newPlatform.hasObstacle = true;
                newPlatform.obstacleSymbol = OBSTACLE_SYMBOLS[Math.floor(Math.random() * OBSTACLE_SYMBOLS.length)];
                lastPlatformHadObstacle = true;
            } else {
                lastPlatformHadObstacle = false; 
            }

            if (Math.random() < 0.65 && platformType !== 'divider' && !newPlatform.hasObstacle) { 
                softwareItems.push({
                    x: platformX + platformWidth / 2, 
                    y: yPos - (gameHeight*0.055), 
                    icon: SOFTWARE_SYMBOLS[Math.floor(Math.random() * SOFTWARE_SYMBOLS.length)],
                    size: gameWidth * 0.06
                });
            }
        }
        
        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y - cameraY);

            const bodyWidth = player.width * 0.9;
            const bodyHeight = player.height * 0.95;
            
            ctx.fillStyle = '#2c3e50';
            ctx.beginPath();
            ctx.ellipse(player.width / 2, player.height / 2, bodyWidth / 2, bodyHeight / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.ellipse(player.width / 2, player.height * 0.6, bodyWidth / 2.5, bodyHeight / 2.5, 0, 0, Math.PI * 2);
            ctx.fill();

            const eyeY = player.height * 0.35;
            const eyeWidth = player.width * 0.08;
            const eyeHeight = player.height * 0.12;
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.ellipse(player.width * 0.35, eyeY, eyeWidth, eyeHeight, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(player.width * 0.65, eyeY, eyeWidth, eyeHeight, 0, 0, Math.PI * 2);
            ctx.fill();

            const beakY = player.height * 0.5;
            ctx.fillStyle = '#f39c12';
            ctx.beginPath();
            ctx.moveTo(player.width / 2, beakY);
            ctx.lineTo(player.width * 0.35, beakY + player.height * 0.1);
            ctx.lineTo(player.width * 0.65, beakY + player.height * 0.1);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        function drawPlatforms() {
            platforms.forEach(p => {
                if (p.y - cameraY > gameHeight || p.y + p.height - cameraY < 0) return;
                
                let platformColor = p.isBroken ? PLATFORM_COLORS.breakable.brokenColor : p.color;
                
                ctx.shadowColor = p.isBroken || p.type === 'divider' ? 'transparent' : (p.shadowColor || '#0AF');
                ctx.shadowBlur = p.isBroken || p.type === 'divider' ? 0 : 10; 
                
                ctx.fillStyle = platformColor;
                ctx.beginPath();
                ctx.roundRect(p.x, p.y - cameraY, p.width, p.height, 5); 
                ctx.fill();
                
                ctx.strokeStyle = p.borderColor;
                ctx.lineWidth = 2; 
                ctx.stroke();
                
                ctx.shadowBlur = 0;

                if (p.hasObstacle) {
                    ctx.fillStyle = '#FF4136';
                    ctx.font = `${player.height * 0.7}px 'Press Start 2P'`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const obstacleY = p.y - cameraY - player.height * 0.4;
                    ctx.fillText(p.obstacleSymbol, p.x + p.width / 2, obstacleY);
                }
            });
        }

        function drawSoftwareItems() {
            softwareItems.forEach(item => {
                if (item.y - cameraY > gameHeight || item.y + item.size - cameraY < 0) return;
                
                ctx.font = `${item.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(item.icon, item.x, item.y - cameraY);
            });
        }
        
        function updateParticles() { 
             for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.radius *= 0.97;
                p.life--;
                if (p.life <= 0 || p.radius < 0.5) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() { 
            particles.forEach(p => {
                if (p.y - cameraY > gameHeight || p.y + p.radius*2 - cameraY < 0) return;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y - cameraY, p.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function update() {
            if (gameState !== 'playing') return;

            if (player.vx) {
                player.x += player.vx;
                if (player.x <= 0) {
                    player.x = 0;
                    player.vx *= -1;
                }
                if (player.x + player.width >= gameWidth) {
                    player.x = gameWidth - player.width;
                    player.vx *= -1;
                }
            }

            player.vy += player.gravity;
            player.y += player.vy;

            platforms.forEach(p => {
                if (p.type === 'breakable' && p.isBroken && p.breakTimer <= 0) return; 

                if (player.vy >= 0 && 
                    player.x + player.width > p.x && 
                    player.x < p.x + p.width &&
                    player.y + player.height > p.y &&
                    player.y + player.height < p.y + p.height + player.vy) {
                    
                    player.y = p.y - player.height;
                    player.canDoubleJump = true;
                    
                    player.vy = -player.jumpStrength;
                    if (soundInitialized) jumpSound.triggerAttackRelease("C4", "16n", Tone.now());

                    if (p.type === 'breakable' && !p.isBroken) {
                        p.isBroken = true; 
                        p.breakTimer = 240;
                        if (soundInitialized) breakSound.triggerAttackRelease("B1", "8n", Tone.now());
                    } else if (p.type === 'boost') {
                        player.vy = -player.boostJumpStrength;
                        if (soundInitialized) boostSound.triggerAttackRelease("A3", "8n", Tone.now() + 0.01); 
                    }
                    if (p.hasObstacle) {
                        let reason = "um obstáculo";
                        switch (p.obstacleSymbol) {
                            case '💲': reason = "os custos altos"; break;
                            case '🐛': reason = "os bugs"; break;
                            case '🔒': reason = "sistemas fechados"; break;
                            case '💀': reason = "o spyware"; break;
                            case '⛓️': reason = "o DRM"; break;
                        }
                        takeDamage(`Cuidado com ${reason}!`);
                    }
                }
                if (p.type === 'breakable' && p.isBroken && p.breakTimer > 0) p.breakTimer--;
            });
            
            for (let i = softwareItems.length - 1; i >= 0; i--) {
                const item = softwareItems[i];
                if (player.x < item.x + item.size / 2 && player.x + player.width > item.x - item.size / 2 &&
                    player.y < item.y + item.size / 2 && player.y + player.height > item.y - item.size / 2) {
                    softwareItems.splice(i, 1);
                    collectedSoftware++;
                    if (soundInitialized) collectSound.triggerAttackRelease("B5", "24n", Tone.now()); 
                    updateHUD();
                }
            }

            const targetCameraY = player.y - gameHeight * 0.60;
            if (targetCameraY < cameraY) cameraY += (targetCameraY - cameraY) * 0.1;
            
            if (platforms.length > 0) {
                const lastGeneratedPlatform = platforms[platforms.length -1];
                if (lastGeneratedPlatform.y - cameraY > -gameHeight * 0.8) { 
                    let nextY = lastGeneratedPlatform.y - (gameHeight * (0.15 + Math.random() * 0.15));
                    let shouldForceDivider = DIVIDER_INTERVAL_Y && (lastDividerY - nextY) >= DIVIDER_INTERVAL_Y;
                    generateNewElements(nextY, false, shouldForceDivider);
                }
            }

            platforms = platforms.filter(p => p.y - cameraY < gameHeight + 50 && !(p.type === 'breakable' && p.isBroken && p.breakTimer <=0));
            softwareItems = softwareItems.filter(c => c.y - cameraY < gameHeight + 50);

            score = Math.max(0, Math.floor((initialPlayerWorldY - player.y) / 10));
            updateHUD();
            
            if (player.vy < 0 ) {
                for (let i = 0; i < 3; i++) {
                    particles.push({
                        x: player.x + player.width / 2 + (Math.random() - 0.5) * (player.width * 0.4),
                        y: player.y + player.height,
                        radius: Math.random() * 2 + 1.5, 
                        vx: (Math.random() - 0.5) * (player.speed * 0.25),
                        vy: (Math.random() * 0.5 + 0.5) * (player.jumpStrength * 0.05),
                        life: 20 + Math.random() * 20, 
                        color: (Math.random() < 0.5) ? `rgba(0,220,255,${0.5 + Math.random()*0.4})` : `rgba(255,255,255,${0.4 + Math.random()*0.3})`
                    });
                }
            }
            updateParticles();
            
            if (player.y - cameraY > gameHeight + player.height * 1.5) gameOver("Perdido no código proprietário!");
        }
        
        function takeDamage(reason) {
            if (gameState !== 'playing') return;
            if (soundInitialized) hurtSound.triggerAttackRelease("16n", Tone.now()); 
            gameOver(reason);
        }

        function handleTouch(event) {
            if (gameState !== 'playing') return;
            if (!soundInitialized) initSounds();

            const touchX = (event.touches ? event.touches[0].clientX : event.clientX) - canvas.getBoundingClientRect().left;
            
            const centerZoneStart = gameWidth * 0.3;
            const centerZoneEnd = gameWidth * 0.7;

            if (touchX > centerZoneStart && touchX < centerZoneEnd) {
                if (player.canDoubleJump) {
                    player.vy = -player.doubleJumpStrength;
                    player.canDoubleJump = false;
                    if (soundInitialized) doubleJumpSound.triggerAttackRelease("G4", "16n", Tone.now());
                }
            } else {
                player.vx = (touchX > gameWidth / 2 ? 1 : -1) * player.speed;
            }
        }

        function gameOver(reason = "Fim de Jogo!") {
            gameState = 'gameOver';
            messageTitle.textContent = reason;
            finalScoreMessage.textContent = `Seu progresso: ${score}Kb`;
            finalSoftwareMessage.textContent = `Softwares coletados: ${collectedSoftware}`;
            messageOverlay.style.display = 'flex';
        }
        
        function updateHUD() {
            scoreDisplay.textContent = `Progresso: ${score}Kb`;
            softwareCountDisplay.textContent = collectedSoftware;
        }

        function draw() {
            ctx.fillStyle = '#0a0313';
            ctx.fillRect(0, 0, gameWidth, gameHeight);
            drawStars();
            ctx.save();
            drawPlatforms(); 
            drawSoftwareItems(); 
            drawParticles(); 
            drawPlayer();
            ctx.restore();
            requestAnimationFrame(draw);
        }
        
        let lastTime = 0; 
        const frameInterval = 1000 / 60;
        function gameLoop(currentTime) {
            requestAnimationFrame(gameLoop);
            const deltaTime = currentTime - lastTime;
            
            if (deltaTime >= frameInterval) { 
                lastTime = currentTime - (deltaTime % frameInterval);
                if (gameState === 'playing') update();
            }
        }

        document.body.addEventListener('click', initSounds, { once: true });
        document.body.addEventListener('touchstart', initSounds, { once: true });
        touchControl.addEventListener('mousedown', (e) => { e.preventDefault(); handleTouch(e); }); 
        touchControl.addEventListener('touchstart', (e) => { e.preventDefault(); handleTouch(e); });
        
        touchControl.addEventListener('mouseup', () => { if(gameState === 'playing') player.vx = 0; });
        touchControl.addEventListener('touchend', () => { if(gameState === 'playing') player.vx = 0; });

        restartButton.addEventListener('click', initGame);
        window.addEventListener('resize', () => { if (gameState === 'playing' || gameState === 'gameOver') initGame(); });

        initGame();
        requestAnimationFrame(gameLoop);
        requestAnimationFrame(draw);
    </script>
</body>
</html>
